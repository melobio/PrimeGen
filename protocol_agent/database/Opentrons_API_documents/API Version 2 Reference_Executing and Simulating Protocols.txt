
opentrons.execute: functions and entrypoint for running protocols

This module has functions that can be imported to provide protocol contexts for running protocols during interactive sessions like Jupyter or just regular python shells. It also provides a console entrypoint for running a protocol from the command line.

opentrons.execute.**execute**(*protocol_file: Union[BinaryIO, TextIO]*, *protocol_name: [str](https://docs.python.org/3/library/stdtypes.html#str)*, *propagate_logs: [bool](https://docs.python.org/3/library/functions.html#bool) = False*, *log_level: [str](https://docs.python.org/3/library/stdtypes.html#str) = 'warning'*, *emit_runlog: Union[Callable[[Union[opentrons.commands.types.DropTipMessage, opentrons.commands.types.PickUpTipMessage, opentrons.commands.types.ReturnTipMessage, opentrons.commands.types.AirGapMessage, opentrons.commands.types.TouchTipMessage, opentrons.commands.types.BlowOutMessage, opentrons.commands.types.MixMessage, opentrons.commands.types.TransferMessage, opentrons.commands.types.DistributeMessage, opentrons.commands.types.ConsolidateMessage, opentrons.commands.types.DispenseMessage, opentrons.commands.types.AspirateMessage, opentrons.commands.types.HomeMessage, opentrons.commands.types.HeaterShakerSetTargetTemperatureMessage, opentrons.commands.types.HeaterShakerWaitForTemperatureMessage, opentrons.commands.types.HeaterShakerSetAndWaitForShakeSpeedMessage, opentrons.commands.types.HeaterShakerOpenLabwareLatchMessage, opentrons.commands.types.HeaterShakerCloseLabwareLatchMessage, opentrons.commands.types.HeaterShakerDeactivateShakerMessage, opentrons.commands.types.HeaterShakerDeactivateHeaterMessage, opentrons.commands.types.ThermocyclerCloseMessage, opentrons.commands.types.ThermocyclerWaitForLidTempMessage, opentrons.commands.types.ThermocyclerDeactivateMessage, opentrons.commands.types.ThermocyclerDeactivateBlockMessage, opentrons.commands.types.ThermocyclerDeactivateLidMessage, opentrons.commands.types.ThermocyclerSetLidTempMessage, opentrons.commands.types.ThermocyclerWaitForTempMessage, opentrons.commands.types.ThermocyclerWaitForHoldMessage, opentrons.commands.types.ThermocyclerExecuteProfileMessage, opentrons.commands.types.ThermocyclerSetBlockTempMessage, opentrons.commands.types.ThermocyclerOpenMessage, opentrons.commands.types.TempdeckSetTempMessage, opentrons.commands.types.TempdeckDeactivateMessage, opentrons.commands.types.MagdeckEngageMessage, opentrons.commands.types.MagdeckDisengageMessage, opentrons.commands.types.MagdeckCalibrateMessage, opentrons.commands.types.CommentMessage, opentrons.commands.types.DelayMessage, opentrons.commands.types.PauseMessage, opentrons.commands.types.ResumeMessage, opentrons.commands.types.MoveToMessage]], NoneType], NoneType] = None*, *custom_labware_paths: Union[List[[str](https://docs.python.org/3/library/stdtypes.html#str)], NoneType] = None*, *custom_data_paths: Union[List[[str](https://docs.python.org/3/library/stdtypes.html#str)], NoneType] = None*) → [None](https://docs.python.org/3/library/constants.html#None)

Run the protocol itself.

This is a one-stop function to run a protocol, whether python or json, no matter the api version, from external (i.e. not bound up in other internal server infrastructure) sources.

To run an opentrons protocol from other places, pass in a file like object as protocol_file; this function either returns (if the run has no problems) or raises an exception.

To call from the command line use either the autogenerated entrypoint

`opentrons_execute` or `python -m opentrons.execute`.

Parameters:

- **protocol_file** – The protocol file to execute

- **protocol_name** – The name of the protocol file. This is required internally, but it may not be a thing we can get from the protocol_file argument.

- **propagate_logs** – Whether this function should allow logs from the Opentrons stack to propagate up to the root handler. This can be useful if you’re integrating this function in a larger application, but most logs that occur during protocol simulation are best associated with the actions in the protocol that cause them. Default: `False`

- **log_level** – The level of logs to emit on the command line: `"debug"`, `"info"`, `"warning"`, or `"error"`. Defaults to `"warning"`.

- **emit_runlog** –

  A callback for printing the run log. If specified, this will be called whenever a command adds an entry to the run log, which can be used for display and progress estimation. If specified, the callback should take a single argument (the name doesn’t matter) which will be a dictionary:

  ```python
  {
    'name': command_name,
    'payload': {
      'text': string_command_text,
      # The rest of this struct is
      # command-dependent; see
      # opentrons.commands.commands.
     }
  }
  ```

  > **Note：**
  >
  > In older software versions, `payload["text"]` was a [format string](https://docs.python.org/3/library/string.html#formatstrings). To get human-readable text, you had to do `payload["text"].format(**payload)`. Don’t do that anymore. If `payload["text"]` happens to contain any `{` or `}` characters, it can confuse `.format()` and cause it to raise a `KeyError`.
  >
  > 

- **custom_labware_paths** – A list of directories to search for custom labware. Loads valid labware from these paths and makes them available to the protocol context. If this is `None` (the default), and this function is called on a robot, it will look in the `labware` subdirectory of the Jupyter data directory.

- **custom_data_paths** – A list of directories or files to load custom data files from. Ignored if the apiv2 feature flag if not set. Entries may be either files or directories. Specified files and the non-recursive contents of specified directories are presented by the protocol context in `ProtocolContext.bundled_data`.

opentrons.execute.**get_arguments**(*parser: [argparse.ArgumentParser](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser)*) → [argparse.ArgumentParser](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser)

Get the argument parser for this module

Useful if you want to use this module as a component of another CLI program and want to add its arguments.

Parameters:**parser** – A parser to add arguments to.

Returns argparse.ArgumentParser:The parser with arguments added.



opentrons.execute.**get_protocol_api**(*version: Union[[str](https://docs.python.org/3/library/stdtypes.html#str), opentrons.protocols.api_support.types.APIVersion]*, *bundled_labware: Union[Dict[str, ForwardRef('LabwareDefinitionDict')], NoneType] = None*, *bundled_data: Union[Dict[[str](https://docs.python.org/3/library/stdtypes.html#str), [bytes](https://docs.python.org/3/library/stdtypes.html#bytes)], NoneType] = None*, *extra_labware: Union[Dict[str, ForwardRef('LabwareDefinitionDict')], NoneType] = None*) → [opentrons.protocol_api.protocol_context.ProtocolContext](https://docs.opentrons.com/v2/new_protocol_api.html#opentrons.protocol_api.ProtocolContext)

Build and return a `protocol_api.ProtocolContext` connected to the robot.

This can be used to run protocols from interactive Python sessions such as Jupyter or an interpreter on the command line:

```python
from opentrons.execute import get_protocol_api
>>> protocol = get_protocol_api('2.0')
>>> instr = protocol.load_instrument('p300_single', 'right')
>>> instr.home()
```

When this function is called, modules and instruments will be recached.

Parameters:

- **version** – The API version to use. This must be lower than `opentrons.protocol_api.MAX_SUPPORTED_VERSION`. It may be specified either as a string (`'2.0'`) or as a `protocols.types.APIVersion` (`APIVersion(2, 0)`).
- **bundled_labware** – If specified, a mapping from labware names to labware definitions for labware to consider in the protocol. Note that if you specify this, _only_ labware in this argument will be allowed in the protocol. This is preparation for a beta feature and is best not used.
- **bundled_data** – If specified, a mapping from filenames to contents for data to be available in the protocol from [`opentrons.protocol_api.ProtocolContext.bundled_data`](https://docs.opentrons.com/v2/new_protocol_api.html#opentrons.protocol_api.ProtocolContext.bundled_data).
- **extra_labware** – A mapping from labware load names to custom labware definitions. If this is `None` (the default), and this function is called on a robot, it will look for labware in the `labware` subdirectory of the Jupyter data directory.

Returns:The protocol context.



opentrons.execute.**main**() → [int](https://docs.python.org/3/library/functions.html#int)

Handler for command line invocation to run a protocol.

Parameters:**argv** – The arguments the program was invoked with; this is usually [`sys.argv`](https://docs.python.org/3/library/sys.html#sys.argv) but if you want to override that you can.

Returns int:A success or failure value suitable for use as a shell return code passed to [`sys.exit`](https://docs.python.org/3/library/sys.html#sys.exit) (0 means success, anything else is a kind of failure).



opentrons.simulate: functions and entrypoints for simulating protocols

This module has functions that provide a console entrypoint for simulating a protocol from the command line.



opentrons.simulate.**allow_bundle**() → [bool](https://docs.python.org/3/library/functions.html#bool)

Check if bundling is allowed with a special not-exposed-to-the-app flag.

Returns `True` if the environment variable `OT_API_FF_allowBundleCreation` is `"1"`



opentrons.simulate.**bundle_from_sim**(*protocol: opentrons.protocols.types.PythonProtocol*, *context: [opentrons.protocol_api.protocol_context.ProtocolContext](https://docs.opentrons.com/v2/new_protocol_api.html#opentrons.protocol_api.ProtocolContext)*) → opentrons.protocols.types.BundleContents[¶](https://docs.opentrons.com/v2/new_protocol_api.html#opentrons.simulate.bundle_from_sim)

From a protocol, and the context that has finished simulating that protocol, determine what needs to go in a bundle for the protocol.



opentrons.simulate.**format_runlog**(*runlog: List[Mapping[[str](https://docs.python.org/3/library/stdtypes.html#str), Any]]*) → [str](https://docs.python.org/3/library/stdtypes.html#str)

Format a run log (return value of [`simulate`](https://docs.opentrons.com/v2/new_protocol_api.html#opentrons.simulate.simulate)) into a human-readable string

Parameters:**runlog** – The output of a call to [`simulate`](https://docs.opentrons.com/v2/new_protocol_api.html#opentrons.simulate.simulate)



opentrons.simulate.**get_arguments**(*parser: [argparse.ArgumentParser](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser)*) → [argparse.ArgumentParser](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser)

Get the argument parser for this module

Useful if you want to use this module as a component of another CLI program and want to add its arguments.



Parameters:**parser** – A parser to add arguments to. If not specified, one will be created.

Returns argparse.ArgumentParser:The parser with arguments added.



opentrons.simulate.**get_protocol_api**(*version: Union[str, opentrons.protocols.api_support.types.APIVersion], bundled_labware: Union[Dict[str, ForwardRef('LabwareDefinitionDict')], NoneType] = None, bundled_data: Union[Dict[str, bytes], NoneType] = None, extra_labware: Union[Dict[str, ForwardRef('LabwareDefinitionDict')], NoneType] = None, hardware_simulator: Union[opentrons.hardware_control.thread_manager.ThreadManager[Union[opentrons.hardware_control.protocols.HardwareControlInterface[opentrons.hardware_control.robot_calibration.RobotCalibration, opentrons.types.Mount, opentrons.config.types.RobotConfig], opentrons.hardware_control.protocols.FlexHardwareControlInterface[opentrons.hardware_control.ot3_calibration.OT3Transforms, Union[opentrons.types.Mount, opentrons.hardware_control.types.OT3Mount], opentrons.config.types.OT3Config]]], NoneType] = None, \*, robot_type: Union[typing_extensions.Literal['OT-2', 'Flex'], NoneType] = None*) → [opentrons.protocol_api.protocol_context.ProtocolContext](https://docs.opentrons.com/v2/new_protocol_api.html#opentrons.protocol_api.ProtocolContext)



Build and return a `protocol_api.ProtocolContext` connected to Virtual Smoothie.

This can be used to run protocols from interactive Python sessions such as Jupyter or an interpreter on the command line:

```python
from opentrons.simulate import get_protocol_api
>>> protocol = get_protocol_api('2.0')
>>> instr = protocol.load_instrument('p300_single', 'right')
>>> instr.home()
```

Parameters:

- **version** – The API version to use. This must be lower than `opentrons.protocol_api.MAX_SUPPORTED_VERSION`. It may be specified either as a string (`'2.0'`) or as a `protocols.types.APIVersion` (`APIVersion(2, 0)`).

- **bundled_labware** – If specified, a mapping from labware names to labware definitions for labware to consider in the protocol. Note that if you specify this, _only_ labware in this argument will be allowed in the protocol. This is preparation for a beta feature and is best not used.

- **bundled_data** – If specified, a mapping from filenames to contents for data to be available in the protocol from [`opentrons.protocol_api.ProtocolContext.bundled_data`](https://docs.opentrons.com/v2/new_protocol_api.html#opentrons.protocol_api.ProtocolContext.bundled_data).

- **extra_labware** – A mapping from labware load names to custom labware definitions. If this is `None` (the default), and this function is called on a robot, it will look for labware in the `labware` subdirectory of the Jupyter data directory.

- **hardware_simulator** – If specified, a hardware simulator instance.

- **robot_type** – The type of robot to simulate: either `"Flex"` or `"OT-2"`. If you’re running this function on a robot, the default is the type of that robot. Otherwise, the default is `"OT-2"`, for backwards compatibility.

  

  Returns:The protocol context.

opentrons.simulate.**main**() → [int](https://docs.python.org/3/library/functions.html#int)

Run the simulation

opentrons.simulate.**simulate**(*protocol_file: Union[BinaryIO, TextIO]*, *file_name: Union[[str](https://docs.python.org/3/library/stdtypes.html#str), NoneType] = None*, *custom_labware_paths: Union[List[[str](https://docs.python.org/3/library/stdtypes.html#str)], NoneType] = None*, *custom_data_paths: Union[List[[str](https://docs.python.org/3/library/stdtypes.html#str)], NoneType] = None*, *propagate_logs: [bool](https://docs.python.org/3/library/functions.html#bool) = False*, *hardware_simulator_file_path: Union[[str](https://docs.python.org/3/library/stdtypes.html#str), NoneType] = None*, *duration_estimator: Union[opentrons.protocols.duration.estimator.DurationEstimator, NoneType] = None*, *log_level: [str](https://docs.python.org/3/library/stdtypes.html#str) = 'warning'*) → Tuple[List[Mapping[[str](https://docs.python.org/3/library/stdtypes.html#str), Any]], Union[opentrons.protocols.types.BundleContents, NoneType]]



Simulate the protocol itself.

This is a one-stop function to simulate a protocol, whether python or json, no matter the api version, from external (i.e. not bound up in other internal server infrastructure) sources.

To simulate an opentrons protocol from other places, pass in a file like object as protocol_file; this function either returns (if the simulation has no problems) or raises an exception.



To call from the command line use either the autogenerated entrypoint `opentrons_simulate` (`opentrons_simulate.exe`, on windows) or `python -m opentrons.simulate`.



The return value is the run log, a list of dicts that represent the commands executed by the robot; and either the contents of the protocol that would be required to bundle, or `None`.



Each dict element in the run log has the following keys:

- `level`: The depth at which this command is nested. If this an aspirate inside a mix inside a transfer, for instance, it would be 3.

- `payload`: The command. The human-readable run log text is available at `payload["text"]`. The other keys of `payload` are command-dependent; see `opentrons.commands`.

  > **Note:**
  >
  > 
  >
  > In older software versions, `payload["text"]` was a [format string](https://docs.python.org/3/library/string.html#formatstrings). To get human-readable text, you had to do `payload["text"].format(**payload)`. Don’t do that anymore. If `payload["text"]` happens to contain any `{` or `}` characters, it can confuse `.format()` and cause it to raise a `KeyError`.

* `logs`: Any log messages that occurred during execution of this command, as a standard Python [`LogRecord`](https://docs.python.org/3/library/logging.html#logging.LogRecord).



Parameters:

- **protocol_file** – The protocol file to simulate.
- **file_name** – The name of the file
- **custom_labware_paths** – A list of directories to search for custom labware. Loads valid labware from these paths and makes them available to the protocol context. If this is `None` (the default), and this function is called on a robot, it will look in the `labware` subdirectory of the Jupyter data directory.
- **custom_data_paths** – A list of directories or files to load custom data files from. Ignored if the apiv2 feature flag if not set. Entries may be either files or directories. Specified files and the non-recursive contents of specified directories are presented by the protocol context in `protocol_api.ProtocolContext.bundled_data`.
- **hardware_simulator_file_path** – A path to a JSON file defining a hardware simulator.
- **duration_estimator** – For internal use only. Optional duration estimator object.
- **propagate_logs** – Whether this function should allow logs from the Opentrons stack to propagate up to the root handler. This can be useful if you’re integrating this function in a larger application, but most logs that occur during protocol simulation are best associated with the actions in the protocol that cause them. Default: `False`
- **log_level** – The level of logs to capture in the run log: `"debug"`, `"info"`,"warning", or "error". Defaults to "warning".

Returns:A tuple of a run log for user output, and possibly the required data to write to a bundle to bundle this protocol. The bundle is only emitted if bundling is allowed and this is an unbundled Protocol API v2 python protocol. In other cases it is None.